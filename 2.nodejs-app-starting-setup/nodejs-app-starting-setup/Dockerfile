#FROM - 시작(저장된 node 이미지를 기반)
FROM node

#3. 
#도커에게 모든 후속 명령이 app 폴더 내부에서 실행됨을 알립니다.
WORKDIR /app

#1. 
#첫 번째 경로(.)는 컨테이너의 외부, 이미지의 외부 경로
#이미지로 복사되어야 할 파일들이 있는 곳
#(컨테이너 또한 이미지는 환경과 코드를 갖고 있으며 거기에서 실행된다.)
#첫 번째 .은 이 프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야 한다고
#도커에게 알리는 것
#COPY .(Host file system) .(Image/container file system)
#두 번째 .은 그 파일을 저장해야 하는 이미지 내부의 경로
#모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는
#로컬 머신의 파일 시스템에서 완전히 분리된 자체 내부 파일 시스템이 있습니다.
#도커 컨테이너 내부에 숨겨져 있습니다.
#실제로 여기에서는 루트 폴더, 즉, 도커 컨테이너의 루트 엔트리를 사용하지 않고
#전적으로 사용자가 선택한 서브 폴더를 사용하는 것이 좋습니다.
#COPY . .

#원하는 이름 -> /app
#이제 Dockerfile과 동일한 폴더에 있는 모든 파일이 
#컨테이너 내부의 app 폴더에 복사됩니다.
#그리고 이 폴더가 존재하지 않는 경우에는 이미지와 컨테이너에 생성됩니다.
#COPY . /app

#4.
#두 번째 ./는 상대 경로 /app을 나타냅니다.
#명시적으로 COPY . /app으로 설정해도 됩니다.
#어떤 폴더에 있는지 알 수 있기 때문에 더 선호되는 방법입니다.
#COPY . ./
COPY . ./app

#2.
#도커에 npm install에 해당하는 명령어가 있습니다. (= RUN npm install)
#WORKDIR로 작업 폴더를 설정해 현재 폴더에 npm install을 하지 않도록 합니다.
RUN npm install

#6.
#Dockerfile의 마지막 명령 전에 이 컨테이너가 시작될 때
#우리의 로컬 시스템에 특정 포트를 노출하고 싶다는 것을
#도커에 알리는 EXPOSE 80 명령을 추가해야 합니다.
#이 컨테이너를 실행할 우리의 로컬 머신에게 말이죠.
#이 80 포트를 수신하고 있는 컨테이너를 실행할 수 있게 됩니다.
EXPOSE 80

#5.
#모든 작업이 완료되면 서버를 시작하라는 명령어를 적어야합니다.
#RUN node server.js라고 할 수 있지만, 틀립니다. 
#이 이미지가 빌드될 때 마다 실행되어야 하기 때문입니다.
#여기 있는 모든 것은 이미지 설정을 위한 도커에 대한 명령입니다.
#이미지는 컨테이너의 템플릿이어야 함을 명시하세요.
#이미지를 실행하는 것이 아니라
#이미지를 기반으로 컨테이너를 실행하는 겁니다.

#컨테이너를 시작하는 경우에만 서버를 시작하고 싶습니다.
#하나의 동일한 이미지에서 여러 컨테이너를 시작하면 노드 서버도 여러개 실행됩니다.
#이를 위한 명령어 CMD명령이있습니다.
#RUN과 차이점은 이미지가 생성될 때 실행되지 않고
#이미지를 기반으로 컨테이너가 시작될 때 실행된다는 겁니다.
#그것이 우리가 원하는 것입니다.

#CMD에 특정하지 않으면 베이스 이미지가 실행되며, 그게 없는 경우 에러가 발생합니다.
CMD ["node","server.js"]